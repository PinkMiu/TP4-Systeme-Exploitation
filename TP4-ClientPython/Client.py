import os

class Client:  ## S,occupe de la syncro (On peux avoir une méthode syncronisation)
    """
    Classe représentant le client
    """

    def __init__(self, connexion, protocole, fileManager):
        self.connexion = connexion
        self.protocol = protocole
        self.fileManager = fileManager
        self.rootFolder = 'Dropbox_tp4'
        self.connexion.connect()

    def askServer(self, toSend):  ##Testé
        self.connexion.send(toSend)
        data = self.connexion.receive()

        return data

    def bonjour(self): ##Fonctionnel
        data = self.protocol.generateHelloServer()
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer)
        return answer

    def serverName(self): ##Fonctionnel
        data = self.protocol.generateServerName()
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer)
        return answer

    def folderList(self, folder): ##Fonctionnel
        data = self.protocol.generate("questionListeDossiers", folder)
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer, "listeDossiers")
        return answer

    def fileList(self, folder): ##Fonctionnel
        data = self.protocol.generate("questionListeFichiers", folder)
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer, "listeFichiers")
        return answer

    def createFolder(self, folder): ##Fonctionnel/Testé
        xmlData = self.protocol.generate("creerDossier", folder)
        serverAnswer = self.askServer(xmlData)
        answer = self.protocol.interpreter(serverAnswer)
        return answer

    def folderExist(self, folder): ##Fonctionnel
        data = self.protocol.generate("questionListeDossiers", folder)
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer, "listeDossiers")

        if (answer == "erreurDossierLecture"):
            return False

        elif (answer == "erreurDossierInexistant"):
            return False

        else:
            ## Si le serveur nous retourne une quelconque suite de fichier, ça veux dire qu'il existe, autrement le serveur nous envoie
            ## une balise nous indiquant l'inexistance du fichier.

            return True

    def fileExist(self, file): ##Fonctionnel
        filePath = self.fileManager.getFilePath(file)
        fileName = self.fileManager.getFileName(file)

        data = self.protocol.generate("questionListeFichiers", filePath)
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer, "listeFichiers")

        if (answer == "erreurDossierLecture"):
            return False

        elif (answer == "erreurDossierInexistant"):
            return False

        elif (answer == ""):
            ## Le dossier existe, mais le fichier n'existe pas dans ce dossier.
            return False
        else:
            filesInAnswer = answer.split(" ")
            for aFile in filesInAnswer:
                if (fileName == aFile):
                    return True

            ## Si le fichier n'est pas retrouver parmis la liste de fichiers envoyés
            return False

    def deleteFolder(self, folder): ##Fonctionnel
        if (self.folderExist(folder)):
            data = self.protocol.generate("supprimerDossier", folder)
            serverAnswer = self.askServer(data)
            answer = self.protocol.interpreter(serverAnswer)

        else:
            answer = "erreurDossierInexistant"

        return answer

    def deleteFile(self, file):
        if (self.fileExist(file)):
            filePath = self.fileManager.getFilePath(file)
            fileName = self.fileManager.getFileName(file)

            data = self.protocol.generateFormatContainingFilePathAndFileName(filePath, fileName, "supprimerFichier")
            convertedData = self.protocol.convertToFormat(data)
            serverAnswer = self.askServer(convertedData)
            answer = self.protocol.interpreter(serverAnswer)

        else:
            answer = "erreurFichierInexistant"

        return answer

    def identicalFile(self, file):
        if (self.fileExist(file)):
            filePath = self.fileManager.getFilePath(file)
            fileName = self.fileManager.getFileName(file)

            data = self.protocol.generateFormatContainingSignatureAndBasicInformation(filePath, fileName, "questionFichierIdentique")
            convertedData = self.protocol.convertToFormat(data)
            serverAnswer = self.askServer(convertedData)
            answer = self.protocol.interpreter(serverAnswer)

        else:
            answer = "erreurFichierInexistant"

        return answer

    def recentFile(self, file):
        if (self.fileExist(file)):
            filePath = self.fileManager.getFilePath(file)
            fileName = self.fileManager.getFileName(file)

            data = self.protocol.generateFormatContainingFilePathAndFileNameAndDate(filePath, fileName, "questionFichierRecent")
            convertedData = self.protocol.convertToFormat(data)
            serverAnswer = self.askServer(convertedData)
            answer = self.protocol.interpreter(serverAnswer)

        else:
            answer = "erreurFichierInexistant"

        return answer

    def upload(self, file):
        filePath = self.fileManager.getFilePath(file)
        fileName = self.fileManager.getFileName(file)

        data = self.protocol.generateFormatContainingUploadInformation(filePath, fileName, "televerserFichier")
        convertedData = self.protocol.convertToFormat(data)
        serverAnswer = self.askServer(convertedData)
        protocolInterpretedAnswer = self.protocol.interpreter(serverAnswer)

        answer = protocolInterpretedAnswer

        return answer


    def download(self, file):
        filePath = self.fileManager.getFilePath(file)
        fileName = self.fileManager.getFileName(file)

        data = self.protocol.generateFormatContainingFilePathAndFileName(filePath, fileName, "telechargerFichier")
        convertedData = self.protocol.convertToFormat(data)
        serverAnswer = self.askServer(convertedData)
        protocolInterpretedAnswer = self.protocol.interpreter(serverAnswer, "fichier")

        if (protocolInterpretedAnswer == "erreurFicherInexistant" or protocolInterpretedAnswer == "erreurFichierLecture"):
            answer = protocolInterpretedAnswer
        else:

            date = protocolInterpretedAnswer["date"]
            content = protocolInterpretedAnswer["contenu"]
            self.fileManager.createFile(filePath, fileName, content, date)
            answer = "ok"

        return answer

    def update(self, folder):
        if (self.folderExist(folder)):
            fileListOnServer = self.fileList(folder) ##String avec les fichiers séparer par des espaces.

            fileListOnClient = next(os.walk(folder))[2]
            fileListOnServer = fileListOnServer.split(" ")

            for file in fileListOnClient:
                completeFilePath = folder + "/" + file
                recentFileAnswer = self.recentFile(completeFilePath)
                if (recentFileAnswer != "erreurFichierLecture"):
                    if (recentFileAnswer == "oui" or recentFileAnswer == "erreurFichierInexistant"):
                        self.upload(completeFilePath)
                    else:
                        self.download(completeFilePath)
                else:
                    answer = "erreurFichierLecture"
                    return answer

            for aFile in fileListOnServer:
                completeFilePath = folder + "/" + aFile
                if (self.fileExistOnClient(fileListOnClient, aFile) == False and aFile != ''):
                    self.download(completeFilePath)

            answer = "ok"

        else:
            answer = "erreurDossierInexistant"

        return answer

    def fileExistOnClient(self, fileList, fileToLookFor):
        for file in fileList:
            if (file == fileToLookFor):
                return True
        return False

    def folderExistOnClient(self):
        currentLocationFolderList = next(os.walk('.'))[1]
        if (self.rootFolder in currentLocationFolderList):
            return True
        else:
            return False

    def automatedSyncronisation(self):
        if (self.folderExistOnClient() == False): ##si le dossier Dropbox_tp4 n'existe pas sur le client, il est créé.
            os.mkdir('Dropbox_tp4')
            self.rootFolder = 'Dropbox_tp4'



    def folderHasNoSubFoldersLeft(self, folder, index = 0):
        if (not (os.walk(folder)[1])):
            return True
        else:
            return False

    def updateFolder(self, folder, index): #recursif

        if (self.folderHasNoSubFoldersLeft(folder, index)):
            self.update(folder)
            index += 1
        else:
            index = 0
            folderList = os.walk(folder)[1]
            subFolder = folderList[index]
            self.updateFolder(subFolder, index)


    def quit(self):
        xmlData = self.protocol.generate("quitter")
        serverAnswer = self.askServer(xmlData)
        answer = self.protocol.interpreter(serverAnswer)
        return answer


