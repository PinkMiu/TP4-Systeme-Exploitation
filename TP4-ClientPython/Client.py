
class Client:  ## S,occupe de la syncro (On peux avoir une méthode syncronisation)
    """
    Classe représentant le client
    """

    def __init__(self, connexion, protocole, fileManager):
        self.connexion = connexion
        self.protocol = protocole
        self.fileManager = fileManager
        self.connexion.connect()

    def askServer(self, toSend):
        self.connexion.send(toSend)
        data = self.connexion.receive()

        return data


    def bonjour(self): ##Fonctionnel
        data = self.protocol.generateHelloServer()
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer)
        return answer

    def serverName(self): ##Fonctionnel
        data = self.protocol.generateServerName()
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer)
        return answer

    def folderList(self, folder): ##Fonctionnel
        data = self.protocol.generate("questionListeDossiers", folder)
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer, "listeDossiers")
        return answer

    def fileList(self, folder): ##Fonctionnel
        data = self.protocol.generate("questionListeFichiers", folder)
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer, "listeFichiers")
        return answer

    def createFolder(self, folder): ##Fonctionnel
        data = self.protocol.generate("creerDossier", folder)
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer)
        return answer

    def folderExist(self, folder): ##Fonctionnel
        data = self.protocol.generate("questionListeDossiers", folder)
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer, "listeDossiers")

        if (answer == "erreurDossierLecture"):
            return False

        elif (answer == "erreurDossierInexistant"):
            return False

        else:
            ## Si le serveur nous retourne une quelconque suite de fichier, ça veux dire qu'il existe, autrement le serveur nous envoie
            ## une balise nous indiquant l'inexistance du fichier.

            return True

    def fileExist(self, file): ##Fonctionnel
        filePath = self.fileManager.getFilePath(file)
        fileName = self.fileManager.getFileName(file)

        data = self.protocol.generate("questionListeFichiers", filePath)
        serverAnswer = self.askServer(data)
        answer = self.protocol.interpreter(serverAnswer, "listeFichiers")

        if (answer == "erreurDossierLecture"):
            return False

        elif (answer == "erreurDossierInexistant"):
            return False

        elif (answer == ""):
            ## Le dossier existe, mais le fichier n'existe pas dans ce dossier.
            return False
        else:
            filesInAnswer = answer.split(" ")
            for aFile in filesInAnswer:
                if (fileName == aFile):
                    return True

            ## Si le fichier n'est pas retrouver parmis la liste de fichiers envoyés
            return False

    def deleteFolder(self, folder): ##Fonctionnel
        if (self.folderExist(folder)):
            data = self.protocol.generate("supprimerDossier", folder)
            serverAnswer = self.askServer(data)
            answer = self.protocol.interpreter(serverAnswer)

        else:
            answer = "erreurDossierInexistant"

        return answer

    def deleteFile(self, file):
        if (self.fileExist(file)):
            filePath = self.fileManager.getFilePath(file)
            fileName = self.fileManager.getFileName(file)

            data = self.protocol.generateFormatContainingFilePathAndFileName(filePath, fileName, "supprimerFichier")
            convertedData = self.protocol.convertToFormat(data)
            serverAnswer = self.askServer(convertedData)
            answer = self.protocol.interpreter(serverAnswer)

        else:
            answer = "erreurFichierInexistant"

        return answer

    def identicalFile(self, file):
        if (self.fileExist(file)):
            filePath = self.fileManager.getFilePath(file)
            fileName = self.fileManager.getFileName(file)

            data = self.protocol.generateFormatContainingSignatureAndBasicInformation(filePath, fileName, "questionFichierIdentique")
            convertedData = self.protocol.convertToFormat(data)
            serverAnswer = self.askServer(convertedData)
            answer = self.protocol.interpreter(serverAnswer)

        else:
            answer = "erreurFichierInexistant"

        return answer

    def recentFile(self, file):
        if (self.fileExist(file)):
            filePath = self.fileManager.getFilePath(file)
            fileName = self.fileManager.getFileName(file)

            data = self.protocol.generateFormatContainingFilePathAndFileNameAndDate(filePath, fileName, "questionFichierRecent")
            convertedData = self.protocol.convertToFormat(data)
            serverAnswer = self.askServer(convertedData)
            answer = self.protocol.interpreter(serverAnswer)

        else:
            answer = "erreurFichierInexistant"

        return answer

    def upload(self, file):
        filePath = self.fileManager.getFilePath(file)
        fileName = self.fileManager.getFileName(file)

        data = self.protocol.generateFormatContainingUploadInformation(filePath, fileName, "televerserFichier")
        convertedData = self.protocol.convertToFormat(data)
        serverAnswer = self.askServer(convertedData)
        protocolInterpretedAnswer = self.protocol.interpreter(serverAnswer)

        answer = protocolInterpretedAnswer

        return answer


    def download(self, file):
        filePath = self.fileManager.getFilePath(file)
        fileName = self.fileManager.getFileName(file)

        data = self.protocol.generateFormatContainingFilePathAndFileName(filePath, fileName, "telechargerFichier")
        convertedData = self.protocol.convertToFormat(data)
        serverAnswer = self.askServer(convertedData)
        protocolInterpretedAnswer = self.protocol.interpreter(serverAnswer, "fichier")

        if (protocolInterpretedAnswer == "erreurFicherInexistant" or protocolInterpretedAnswer == "erreurFichierLecture"):
            answer = protocolInterpretedAnswer
        else:
            splitAnswer = protocolInterpretedAnswer.split(" ")
            content = splitAnswer[1]
            date = splitAnswer[2]
            self.fileManager.createFile(filePath, fileName, content, date)
            answer = "ok"

        return answer

    def update(self, folder):
        if (self.folderExist(folder)):
            fileListOnServer = self.fileList(folder) ##String avec les fichiers séparer par des espaces.

            fileListOnServer = fileListOnServer.split(" ")

            for file in fileListOnServer:
                completeFilePath = folder + file
                recentFileAnswer = self.recentFile(completeFilePath)
                if (recentFileAnswer != "erreurFichierLecture"):
                    if (recentFileAnswer == "oui" or recentFileAnswer == "erreurFichierInexistant"):
                        self.upload(completeFilePath)
                    else:
                        self.download(completeFilePath)

        else:
            return False

        return True

    def quit(self):
        xmlData = self.protocol.generate("quitter")
        serverAnswer = self.askServer(xmlData)
        answer = self.protocol.interpreter(serverAnswer)
        return answer


